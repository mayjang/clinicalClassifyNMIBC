---
title: "assignment2"
output: html_document
date: "2026-02-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## classifier.Rmd
## Run the code in this markdown file first before running classifier_visualizations.Rmd
<!-- Make sure to install the following packages before running the Rmd files. install.packages(c("caret","glmnet","pROC","survival","dplyr","gridExtra")) if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager") BiocManager::install("limma") -->

<!-- Install classifyNMIBC for baseline model: devtools::install_github("sialindskrog/classifyNMIBC", build_vignettes = FALSE, upgrade = "never") -->

```{r library, include=FALSE}
suppressPackageStartupMessages({
  library(caret)
  library(limma)
  library(glmnet)
  library(pROC)
  library(survival)
})

set.seed(1)
```


```{r load_data}

# path to rds files
# fix the path if running from a different environment
uromol_path  <- "/Users/mayjang/Desktop/BIOF520/assignment2/data/UROMOL_TaLG.teachingcohort.rds"
knowles_path <- "/Users/mayjang/Desktop/BIOF520/assignment2/data/knowles_matched_TaLG_final.rds"

uromol  <- readRDS(uromol_path)
knowles <- readRDS(knowles_path)

stopifnot("exprs" %in% names(uromol), "exprs" %in% names(knowles))
uromol$exprs  <- as.matrix(uromol$exprs)
knowles$exprs <- as.matrix(knowles$exprs)


```

```{r recurrence_labeling}

make_recurrence_label <- function(df) {
  y <- suppressWarnings(as.integer(df$Recurrence))
  y[!(y %in% c(0L, 1L))] <- NA_integer_
  y
}
uromol$y  <- make_recurrence_label(uromol)
knowles$y <- make_recurrence_label(knowles)

y_factor <- function(y01) factor(ifelse(y01 == 1, "Rec", "NoRec"), levels = c("NoRec", "Rec"))

```

```{r create_uromol_set}
u_ids <- rownames(uromol$exprs)[!is.na(uromol$y)]
u_y   <- uromol$y[match(u_ids, rownames(uromol$exprs))]
u_y_fac <- y_factor(u_y)

u_expr_lab <- uromol$exprs[u_ids, , drop = FALSE]

get_clinical_df <- function(df) {
  keep <- intersect(
    c("Age", "Sex", "Smoking", "Tumor.size", "Concomitant.CIS", "Incident.tumor", "EAU.risk", "BCG"),
    names(df)
  )
  if (length(keep) == 0) stop("No clinical predictors found")
  clin <- as.data.frame(df[, keep, drop = FALSE], stringsAsFactors = FALSE)
  
  if ("Age" %in% names(clin)) clin$Age <- suppressWarnings(as.numeric(clin$Age))
  for (nm in names(clin)) {
    if (!is.numeric(clin[[nm]])) {
      clin[[nm]] <- trimws(as.character(clin[[nm]]))
      clin[[nm]][is.na(clin[[nm]]) | clin[[nm]] == ""] <- "Unknown"
      clin[[nm]] <- factor(clin[[nm]])
    }
  }
  clin
}

uromol_clin <- get_clinical_df(uromol)
rownames(uromol_clin) <- rownames(uromol$exprs)
u_clin_lab <- uromol_clin[u_ids, , drop = FALSE]

cat("\nUROMOL labeled:", length(u_y_fac), "\n")
print(table(u_y_fac))

```

```{r training_data}
set.seed(1)
idx_test  <- createDataPartition(u_y_fac, p = 0.25, list = FALSE)
idx_train <- setdiff(seq_len(length(u_y_fac)), idx_test)

y_train <- u_y_fac[idx_train]
y_test  <- u_y_fac[idx_test]

```


```{r preprocess_training_data}
impute_numeric_train_median <- function(train_df, others_list) {
  train2 <- train_df
  meds <- list()
  for (nm in names(train2)) {
    if (is.numeric(train2[[nm]])) {
      med <- suppressWarnings(median(train2[[nm]], na.rm = TRUE))
      if (!is.finite(med)) med <- 0
      meds[[nm]] <- med
      train2[[nm]][is.na(train2[[nm]])] <- med
    }
  }
  others2 <- lapply(others_list, function(df) {
    df2 <- df
    for (nm in names(meds)) {
      if (nm %in% names(df2) && is.numeric(df2[[nm]])) {
        df2[[nm]][is.na(df2[[nm]])] <- meds[[nm]]
      }
    }
    df2
  })
  list(train = train2, others = others2)
}

clin_train_raw <- u_clin_lab[idx_train, , drop = FALSE]
clin_test_raw  <- u_clin_lab[idx_test,  , drop = FALSE]
tmp_imp <- impute_numeric_train_median(clin_train_raw, list(clin_test_raw))
clin_train_raw <- tmp_imp$train
clin_test_raw  <- tmp_imp$others[[1]]

dv <- dummyVars(~ ., data = clin_train_raw, fullRank = TRUE)
clin_train <- as.matrix(predict(dv, newdata = clin_train_raw))
clin_test  <- as.matrix(predict(dv, newdata = clin_test_raw))

# Expression : train gene mean fill the NAs 
# and center/scale 
expr_train <- u_expr_lab[idx_train, , drop = FALSE]
expr_test  <- u_expr_lab[idx_test,  , drop = FALSE]

train_gene_mean <- colMeans(expr_train, na.rm = TRUE)
fill_na_with_train_mean <- function(mat, mu) {
  out <- mat
  for (j in seq_along(mu)) {
    v <- out[, j]
    v[is.na(v)] <- mu[j]
    out[, j] <- v
  }
  out
}
expr_train_f <- fill_na_with_train_mean(expr_train, train_gene_mean)
expr_test_f  <- fill_na_with_train_mean(expr_test,  train_gene_mean)

pp_expr <- preProcess(expr_train_f, method = c("center", "scale"))
expr_train_cs <- as.matrix(predict(pp_expr, expr_train_f))
expr_test_cs  <- as.matrix(predict(pp_expr, expr_test_f))


```

```{r feature_selection}
# Candidate feature sets
# Clinical baseline: all available clinical dummy variables
# Transcriptomic: top genes by DE in train only used for combined models + lasso panel

# Transcriptomic candidate genes (limma)
topK_genes_candidate <- 200  
design <- model.matrix(~ y_train)
fit <- lmFit(t(expr_train_cs), design)
fit <- eBayes(fit)
tt <- topTable(fit, coef = 2, number = Inf, adjust.method = "BH", sort.by = "P")
tt <- tt[!is.na(tt$adj.P.Val), , drop = FALSE]
de_genes_cand <- rownames(tt)[1:min(topK_genes_candidate, nrow(tt))]

# Matrices for transcriptomic candidate genes
Xg_train_all <- expr_train_cs[, de_genes_cand, drop = FALSE]
Xg_test_all  <- expr_test_cs[,  de_genes_cand, drop = FALSE]

# Clinical baseline matrices
Xc_train_base <- clin_train
Xc_test_base  <- clin_test

# Combined candidate matrices (clinical baseline + transcriptomic candidates)
X_train_combo_all <- cbind(Xc_train_base, Xg_train_all)
X_test_combo_all  <- cbind(Xc_test_base,  Xg_test_all)

X_train_clin_base <- Xc_train_base
X_test_clin_base  <- Xc_test_base

X_train_de_cand <- Xg_train_all
X_test_de_cand  <- Xg_test_all

y_train01 <- ifelse(y_train == "Rec", 1, 0)
y_test01  <- ifelse(y_test  == "Rec", 1, 0)

cat("\nCandidate genes (train DE):", length(de_genes_cand), "\n")


```
## Model Training

```{r elastic_net}
# Train 4 models to determine the best combination based on UROMOL test outputs:
# Clinical baseline model
# Transcriptomic model (DE candidate genes)
# Combined elastic net model (clinical + DE candidates)
# Combined LASSO small-panel model (clinical + selected gene panel)

ctrl <- trainControl(
  method = "repeatedcv",
  number = 5,
  repeats = 3,
  classProbs = TRUE,
  summaryFunction = twoClassSummary
)

fit_glmnet_caret <- function(Xtr, ytr, alpha_fixed = NULL) {
  set.seed(520)
  if (is.null(alpha_fixed)) {
    train(x = Xtr, y = ytr,
          method = "glmnet",
          metric = "ROC",
          trControl = ctrl,
          tuneLength = 20)
  } else {
    tg <- expand.grid(alpha = alpha_fixed, lambda = exp(seq(log(1e-4), log(1), length.out = 30)))
    train(x = Xtr, y = ytr,
          method = "glmnet",
          metric = "ROC",
          trControl = ctrl,
          tuneGrid = tg)
  }
}

m_clin_base <- fit_glmnet_caret(X_train_clin_base, y_train)

m_de_cand <- fit_glmnet_caret(X_train_de_cand, y_train)

m_combo_en <- fit_glmnet_caret(X_train_combo_all, y_train)

# LASSO selection (alpha=1)
set.seed(1)
cv_lasso <- cv.glmnet(
  x = X_train_combo_all,
  y = y_train01,
  family = "binomial",
  alpha = 1,
  nfolds = 5,
  type.measure = "auc"
)

lambda_panel <- cv_lasso$lambda.1se  
coef_mat <- coef(cv_lasso, s = lambda_panel)
nz <- which(as.vector(coef_mat) != 0)
feat_nz <- rownames(coef_mat)[nz]
feat_nz <- setdiff(feat_nz, "(Intercept)")

if (length(feat_nz) < 2) {
  warning("LASSO panel selected <2 features, lambda.min.")
  lambda_panel <- cv_lasso$lambda.min
  coef_mat <- coef(cv_lasso, s = lambda_panel)
  nz <- which(as.vector(coef_mat) != 0)
  feat_nz <- rownames(coef_mat)[nz]
  feat_nz <- setdiff(feat_nz, "(Intercept)")
}

# Separate genes vs clinical features
panel_genes <- intersect(feat_nz, colnames(X_train_de_cand))
panel_clin  <- setdiff(feat_nz, panel_genes)

cat("\nLASSO panel (lambda.1se):", signif(lambda_panel, 4), "\n")
cat("Selected features total:", length(feat_nz), "\n")
cat("Selected genes:", length(panel_genes), "\n")
cat("Selected clinical dummies:", length(panel_clin), "\n")

# Build reduced matrices for panel model
X_train_panel <- X_train_combo_all[, feat_nz, drop = FALSE]
X_test_panel  <- X_test_combo_all[,  feat_nz, drop = FALSE]

# Fit final fixed-lambda LASSO model 
m_combo_lasso_panel <- glmnet(
  x = X_train_panel,
  y = y_train01,
  family = "binomial",
  alpha = 1,
  lambda = lambda_panel
)

predict_panel_prob <- function(fit, X) {
  as.numeric(predict(fit, newx = X, type = "response"))
}

```



## Validation
```{r knowles_validation}

# Knowles
# Build Knowles expression in train gene space for scaling
# Build Knowles clinical dummy matrix aligned to train
# Knowles matrices for each model

k_ids <- rownames(knowles$exprs)[!is.na(knowles$y)]
k_y_fac <- y_factor(knowles$y[match(k_ids, rownames(knowles$exprs))])

k_expr_raw <- knowles$exprs[k_ids, , drop = FALSE]

train_all_genes <- colnames(u_expr_lab)  

k_full <- matrix(NA_real_, nrow = nrow(k_expr_raw), ncol = length(train_all_genes),
                 dimnames = list(rownames(k_expr_raw), train_all_genes))

present <- intersect(colnames(k_expr_raw), train_all_genes)
k_full[, present] <- k_expr_raw[, present, drop = FALSE]

# Impute NA within present genes using Knowles per gene median
if (length(present) > 0) {
  km <- apply(k_full[, present, drop = FALSE], 2, median, na.rm = TRUE)
  for (j in seq_along(present)) {
    g <- present[j]
    v <- k_full[, g]
    v[is.na(v)] <- km[j]
    k_full[, g] <- v
  }
}

# Fill genes missing in Knowles with train mean so they become around 0 after scaling
miss_train_genes <- train_all_genes[apply(is.na(k_full), 2, all)]
if (length(miss_train_genes) > 0) {
  k_full[, miss_train_genes] <- matrix(train_gene_mean[miss_train_genes],
                                       nrow(k_full), length(miss_train_genes),
                                       byrow = TRUE,
                                       dimnames = list(rownames(k_full), miss_train_genes))
}
if (anyNA(k_full)) {
  for (g in colnames(k_full)) {
    v <- k_full[, g]
    v[is.na(v)] <- train_gene_mean[g]
    k_full[, g] <- v
  }
}

k_expr_cs_all <- as.matrix(predict(pp_expr, k_full))

# Transcriptomic candidates subset 
X_kn_de_cand <- k_expr_cs_all[, de_genes_cand, drop = FALSE]

# Clinical projection aligned to train dummyVars
knowles_clin <- get_clinical_df(knowles)
rownames(knowles_clin) <- rownames(knowles$exprs)
k_clin_lab <- knowles_clin[k_ids, , drop = FALSE]

# make sure same raw clinical columns exist 
for (nm in setdiff(colnames(clin_train_raw), colnames(k_clin_lab))) {
  if (is.numeric(clin_train_raw[[nm]])) {
    k_clin_lab[[nm]] <- NA_real_
  } else {
    k_clin_lab[[nm]] <- factor("Unknown", levels = levels(clin_train_raw[[nm]]))
  }
}


k_clin_imp <- impute_numeric_train_median(clin_train_raw, list(k_clin_lab))$others[[1]]

clin_kn <- as.matrix(predict(dv, newdata = k_clin_imp))

need_cols <- colnames(clin_train)
miss <- setdiff(need_cols, colnames(clin_kn))
if (length(miss) > 0) {
  clin_kn <- cbind(clin_kn, matrix(0, nrow(clin_kn), length(miss),
                                   dimnames = list(rownames(clin_kn), miss)))
}
extra <- setdiff(colnames(clin_kn), need_cols)
if (length(extra) > 0) {
  clin_kn <- clin_kn[, setdiff(colnames(clin_kn), extra), drop = FALSE]
}
clin_kn <- clin_kn[, need_cols, drop = FALSE]

# Knowles matrices for each model
X_kn_clin_base <- clin_kn
X_kn_combo_all <- cbind(X_kn_clin_base, X_kn_de_cand)

k_time <- as.numeric(knowles$RFS_time[match(k_ids, rownames(knowles$exprs))])
k_event <- as.integer(knowles$Recurrence[match(k_ids, rownames(knowles$exprs))])

missing_panel <- setdiff(colnames(X_train_panel), colnames(X_kn_combo_all))
if (length(missing_panel) > 0) {
  stop("Knowles missing panel features: ", paste(missing_panel, collapse = ", "))
}
X_kn_panel <- X_kn_combo_all[, colnames(X_train_panel), drop = FALSE]

# Compute model probabilities
p_kn_panel <- predict_panel_prob(m_combo_lasso_panel, X_kn_panel)

# Also compute combined elastic net probabilities
p_kn_combo_en <- predict(m_combo_en, newdata = X_kn_combo_all, type = "prob")[, "Rec"]

# Clinical baseline prob
p_kn_clin_base <- predict(m_clin_base, newdata = X_kn_clin_base, type = "prob")[, "Rec"]

# Transcriptomic candidate prob
p_kn_de_cand <- predict(m_de_cand, newdata = X_kn_de_cand, type = "prob")[, "Rec"]


```



## classifyNMIBC
```{r nmibc_classifier}
load_or_install_classifyNMIBC <- function() {
  if (!requireNamespace("classifyNMIBC", quietly = TRUE)) {
    if (!requireNamespace("devtools", quietly = TRUE)) {
      install.packages("devtools", repos = "https://cloud.r-project.org")
    }
    devtools::install_github("sialindskrog/classifyNMIBC", build_vignettes = FALSE, upgrade = "never")
  }
  suppressPackageStartupMessages(library(classifyNMIBC))
}
load_or_install_classifyNMIBC()

run_nmibc <- function(expr_samples_x_genes, gene_id = "hgnc_symbol", minCor = 0.2) {
  stopifnot(is.matrix(expr_samples_x_genes))
  x <- t(expr_samples_x_genes)
  x <- as.data.frame(x)
  if (any(duplicated(rownames(x)))) {
    rn <- rownames(x)
    x$.__gene__ <- rn
    x <- aggregate(. ~ .__gene__, data = x, FUN = mean)
    rownames(x) <- x$.__gene__
    x$.__gene__ <- NULL
  }
  classifyNMIBC::classifyNMIBC(x, minCor = minCor, gene_id = gene_id)
}

warn_if_not_logish <- function(mat, name) {
  qs <- suppressWarnings(quantile(as.vector(mat), probs = c(0.01, 0.5, 0.99), na.rm = TRUE))
  if (is.finite(qs[3]) && qs[3] > 100) {
    warning(name, " expression values not log transformed ",
            "classifyNMIBC needs log transformed")
  }
}

u_expr_test_raw <- u_expr_lab[idx_test, , drop = FALSE]
warn_if_not_logish(u_expr_test_raw, "UROMOL test")
warn_if_not_logish(k_expr_raw, "Knowles")

nm_u_test <- tryCatch(run_nmibc(u_expr_test_raw), error = function(e) e)
nm_k      <- tryCatch(run_nmibc(k_expr_raw),      error = function(e) e)

if (inherits(nm_u_test, "error")) stop("classifyNMIBC failed on UROMOL test: ", nm_u_test$message)
if (inherits(nm_k, "error"))      stop("classifyNMIBC failed on Knowles: ", nm_k$message)

col_class <- if ("NMIBC_class" %in% colnames(nm_u_test)) "NMIBC_class" else if ("NMIBC_Class" %in% colnames(nm_u_test)) "NMIBC_Class" else stop("NMIBC class column not found.")

get_cor_col <- function(df, nm) {
  if (nm %in% colnames(df)) return(nm)
  alt <- gsub("\\.", "_", nm)
  if (alt %in% colnames(df)) return(alt)
  stop("Missing expected centroid column: ", nm)
}
c2a <- get_cor_col(nm_u_test, "Class_2a")
c2b <- get_cor_col(nm_u_test, "Class_2b")

nmibc_risk_score <- function(df) pmax(df[[c2a]], df[[c2b]], na.rm = TRUE)

u_nm_score <- nmibc_risk_score(nm_u_test)
k_nm_score <- nmibc_risk_score(nm_k)

# NMIBC threshold learned on UROMOL training data
u_expr_train_raw <- u_expr_lab[idx_train, , drop = FALSE]
warn_if_not_logish(u_expr_train_raw, "UROMOL train")

nm_u_train <- tryCatch(run_nmibc(u_expr_train_raw), error = function(e) e)
if (inherits(nm_u_train, "error")) stop("classifyNMIBC failed on UROMOL train: ", nm_u_train$message)

u_nm_train_score <- nmibc_risk_score(nm_u_train)

nm_thr <- NA_real_
roc_nm <- tryCatch(
  pROC::roc(ifelse(y_train == "Rec", 1, 0), u_nm_train_score, quiet = TRUE),
  error = function(e) NULL
)

if (!is.null(roc_nm)) {
  nm_thr <- as.numeric(pROC::coords(roc_nm, x = "best", best.method = "youden", transpose = FALSE)["threshold"])
} else {
  nm_thr <- median(u_nm_train_score, na.rm = TRUE)
}

cat("\nNMIBC score threshold:", signif(nm_thr, 4), "\n")

nmibc_pred_from_score <- function(score, thr) factor(ifelse(score >= thr, "Rec", "NoRec"), levels = c("NoRec","Rec"))
u_nm_score_pred <- nmibc_pred_from_score(u_nm_score, nm_thr)  # UROMOL TEST preds
k_nm_score_pred <- nmibc_pred_from_score(k_nm_score, nm_thr)  # Knowles preds


```


## Compare 4 models and their metrics
```{r clinical_vs_de}

# Collect probabilities for models
get_probs_all <- function() {
  list(
    clin_base = list(
      train = predict(m_clin_base, newdata = X_train_clin_base, type="prob")[,"Rec"],
      test  = predict(m_clin_base, newdata = X_test_clin_base,  type="prob")[,"Rec"],
      knowles= p_kn_clin_base
    ),
    de_cand = list(
      train = predict(m_de_cand, newdata = X_train_de_cand, type="prob")[,"Rec"],
      test  = predict(m_de_cand, newdata = X_test_de_cand,  type="prob")[,"Rec"],
      knowles= p_kn_de_cand
    ),
    combo_en = list(
      train = predict(m_combo_en, newdata = X_train_combo_all, type="prob")[,"Rec"],
      test  = predict(m_combo_en, newdata = X_test_combo_all,  type="prob")[,"Rec"],
      knowles= p_kn_combo_en
    ),
    combo_panel = list(
      train = predict_panel_prob(m_combo_lasso_panel, X_train_panel),
      test  = predict_panel_prob(m_combo_lasso_panel, X_test_panel),
      knowles= p_kn_panel
    )
  )
}

probs_all <- get_probs_all()

main_model <- "combo_panel"  # "clin_base", "de_cand","combo_en","combo_panel"
probs <- probs_all[[main_model]]

# Thresholds 
get_train_thr <- function(y_train_fac, p_train, method = "youden") {
  ok <- is.finite(p_train) & !is.na(y_train_fac)
  y2 <- y_train_fac[ok]; p2 <- p_train[ok]
  if (length(unique(y2)) < 2) return(NA_real_)
  r <- pROC::roc(y2, p2, levels = c("NoRec","Rec"), direction = "<", quiet = TRUE)
  as.numeric(pROC::coords(r, x="best", best.method = method, transpose = FALSE)["threshold"])
}

thr_by_model <- sapply(names(probs_all), function(m) {
  get_train_thr(y_train, probs_all[[m]]$train, method = "youden")
})

cat("\nTrain-derived thresholds (Youden):\n")
print(data.frame(Model = names(thr_by_model), Thr_train = as.numeric(thr_by_model)))

# Main threshold (TRAIN)
thr_used <- as.numeric(thr_by_model[[main_model]])
cat("\nMy model:", main_model, " | Threshold (UROMOL TRAIN):", round(thr_used, 3), "\n")



```


## What is the best model to use?

```{r pick_best_model}
# Compare models and determine the best one

safe_auc <- function(y_fac, p) {
  ok <- is.finite(p) & !is.na(y_fac)
  y2 <- y_fac[ok]; p2 <- p[ok]
  if (length(unique(y2)) < 2) return(NA_real_)
  as.numeric(pROC::auc(pROC::roc(ifelse(y2 == "Rec", 1, 0), p2, quiet = TRUE)))
}

conf_metrics <- function(y_fac, p, thr) {
  pred <- factor(ifelse(p >= thr, "Rec", "NoRec"), levels = c("NoRec","Rec"))
  cm <- table(True = y_fac, Pred = pred)

  TN <- ifelse("NoRec" %in% rownames(cm) && "NoRec" %in% colnames(cm), cm["NoRec","NoRec"], 0)
  FP <- ifelse("NoRec" %in% rownames(cm) && "Rec"   %in% colnames(cm), cm["NoRec","Rec"],   0)
  FN <- ifelse("Rec"   %in% rownames(cm) && "NoRec" %in% colnames(cm), cm["Rec","NoRec"],   0)
  TP <- ifelse("Rec"   %in% rownames(cm) && "Rec"   %in% colnames(cm), cm["Rec","Rec"],     0)

  acc  <- (TP + TN) / max(1, (TP + TN + FP + FN))
  sens <- TP / max(1, (TP + FN))
  spec <- TN / max(1, (TN + FP))
  ppv  <- TP / max(1, (TP + FP))
  npv  <- TN / max(1, (TN + FN))
  f1   <- if ((ppv + sens) > 0) 2 * ppv * sens / (ppv + sens) else NA_real_

  c(Accuracy=acc, Sensitivity=sens, Specificity=spec, PPV=ppv, NPV=npv, F1=f1,
    TN=TN, FP=FP, FN=FN, TP=TP)
}

model_names <- names(probs_all)

res_test <- do.call(rbind, lapply(model_names, function(m) {
  p_test <- probs_all[[m]]$test
  thr    <- as.numeric(thr_by_model[[m]])   # <-- TRAIN threshold
  auc    <- safe_auc(y_test, p_test)
  mets   <- if (is.na(thr)) rep(NA_real_, 10) else conf_metrics(y_test, p_test, thr)
  data.frame(Model=m, AUC=auc, Thr=thr, t(mets), row.names = NULL, check.names = FALSE)
}))
res_test <- res_test[order(-res_test$AUC), ]
print(res_test)

```
# Based on the table above, combo_panel is the best model to avoid overtreatment of patients based on UROMOL test data metrics.


```{r metrics_table}

# Metrics table (My model vs classifyNMIBC)
# UROMOL test + Knowles

safe_auc <- function(y_fac, p) {
  ok <- is.finite(p) & !is.na(y_fac)
  y2 <- y_fac[ok]; p2 <- p[ok]
  if (length(unique(y2)) < 2) return(NA_real_)
  as.numeric(pROC::auc(pROC::roc(ifelse(y2 == "Rec", 1, 0), p2, quiet = TRUE)))
}

core_metrics <- function(y_fac, p, thr) {
  pred <- factor(ifelse(p >= thr, "Rec", "NoRec"), levels = c("NoRec","Rec"))
  cm <- table(True = y_fac, Pred = pred)

  TN <- ifelse("NoRec" %in% rownames(cm) && "NoRec" %in% colnames(cm), cm["NoRec","NoRec"], 0)
  FP <- ifelse("NoRec" %in% rownames(cm) && "Rec"   %in% colnames(cm), cm["NoRec","Rec"],   0)
  FN <- ifelse("Rec"   %in% rownames(cm) && "NoRec" %in% colnames(cm), cm["Rec","NoRec"],   0)
  TP <- ifelse("Rec"   %in% rownames(cm) && "Rec"   %in% colnames(cm), cm["Rec","Rec"],     0)

  acc  <- (TP + TN) / max(1, (TP + TN + FP + FN))
  sens <- TP / max(1, (TP + FN))
  spec <- TN / max(1, (TN + FP))

  c(Accuracy = acc, Sensitivity = sens, Specificity = spec)
}

p_my_test <- probs_all[[main_model]]$test
mets_my_test <- core_metrics(y_test, p_my_test, thr_used)

p_nm_test <- u_nm_score
mets_nm_test <- core_metrics(y_test, p_nm_test, nm_thr)

has_kn <- exists("k_y_fac") && length(unique(k_y_fac)) >= 2

if (has_kn) {
  p_my_kn <- probs_all[[main_model]]$knowles
  mets_my_kn <- core_metrics(k_y_fac, p_my_kn, thr_used)

  p_nm_kn <- k_nm_score
  mets_nm_kn <- core_metrics(k_y_fac, p_nm_kn, nm_thr)
} else {
  mets_my_kn <- mets_nm_kn <- c(Accuracy=NA, Sensitivity=NA, Specificity=NA)
}

compact_tbl_core <- dplyr::bind_rows(
  data.frame(Dataset = "UROMOL TEST", Model = "My model", Thr = thr_used, t(mets_my_test)),
  data.frame(Dataset = "UROMOL TEST", Model = "classifyNMIBC", Thr = nm_thr, t(mets_nm_test)),
  data.frame(Dataset = "Knowles", Model = "My model", Thr = thr_used, t(mets_my_kn)),
  data.frame(Dataset = "Knowles", Model = "classifyNMIBC", Thr = nm_thr, t(mets_nm_kn))
)

compact_tbl_core <- dplyr::mutate(
  compact_tbl_core,
  dplyr::across(dplyr::where(is.numeric), ~ round(.x, 3))
)


print(compact_tbl_core)


#Save as png
out_dir <- "figures"
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
```
